new Splide('.splide').mount();

// Splide 라이브러리
//  를 사용하여 웹페이지에 캐러셀(슬리이드 쇼)을 생성하는 방법을 보여줍니다.

// new Splide('.splide') 부분은 Splide 인스턴스를 생성하는것 입니다.
// 이때 .Splide 는 HTML 문서에서 캐러셀이 위치할 요소의 CSS 선택자 입니다.

//  .mount() 메서드를 호출하면 Splide 인스턴스가 초기화되고 캐러셀이 웹페이지에 렌더링 됩니다. 이 메서드를 호출하지 않으면 아무 일도 일어나지 않습니다.

// Splide 라이브러리는 다양한 옵션을 제공하여 캐러셀의 동작을 사용자 정의할 수 있습니다. 
// 예를 들어 화살표, 페이지네이션, 드래그 기능 등을 활성화 비활성화 할 수 있습니다.

// 또한 Splide는 다양한 이벤트를 제공하여 개러셀의 상태 변화에 따라 추가 작없을 수행할 수 있습니다.
// 예를 들어 move click resized 이벤트 등을 사용할 수 있습니다.

// 요약
// 위의 코드는 Splide 라이브러리를 사용하여 웹 페이지에 캐러셀을 생성하는 가장 기본적인 방법을 보여줍니다.



// Add contact buttons
const addContactBtns = [...document.querySelectorAll('.profile button')];

addContactBtns.forEach(btn => {
  btn.addEventListener('click', (e)=>{
    if (btn.textContent === 'Added') {
      btn.classList.remove('added');
      e.target.textContent = 'Add contact';
    } else {
      btn.classList.add('added');
      e.target.textContent = 'Added';
    }
  })
})

/*
  btn, e 을 구분해서 사용하는 이유?

  1. btn 은 querySelectorAll로 선택된 각각의 버튼 요소.
    이 변수믄 이벤트 핸들러 함수 내부에서도 사용되어 버튼의 
    텍스트와 클래스를 변경하는데 사용됩니다.

  2. e 는 이벤트 객체.
    이벤트 객체에는 이벤트와 관련된 정보(예: 이벤트가 발생한 요소, 
      이벤트 타입 등)가 포함.

    이 코드에서는 e.target을 사용하여 실제로 클릭된 버튼 요소의 
    텍스트를 변경.

  이벤트 핸들러 함수 내부에서 btn 과 e 를 구분하여 사용하면
  코드의 가독성과 유지보수성이 향상됩니다.

  btn 버튼 요소 자체를 나타내고, 
  e 는 이벤트와 관련되 정보를 나타내므로
  각각의 역할이 명확해집니다.

  예를 들어 이벤트 핸들러 함수 내부에서 btn을 사용하여 버튼의 텍스트를 변경하고,
  e.target을 사용하여 실제로 클릭된 버튼의 텍스트를 변경할 수 있습니다.
 */


/*
    btn.addEventListener('click', (e)=>{ ... });
      이 코드는 각 버튼 요소에 "클릭 이벤트 리스너"를 등록합니다.
      이벤트 리스너 함수의 인자로 "이벤트 객체 e" 가 전달됩니다.

    e.target
      이 코드는 실제로 클릭된 버튼 요소를 가리킵니다.
      이벤트 객체 e의 target 속성은 
      이벤트가 발생한 가장 안쪽의 요소를 나타냅니다.
      따라서 e.target을 사용하여 실제로 클릭된 버튼 요소의 텍스트를 변경할 수 있습니다. 
      이와 달리 btn은 이벤트 리스너가 등록된 버튼 요소 자체를 가리킵니다.

*/


/*
    e.target을 사용하지 않으면 이벤트 핸들러 함수에서 
    이벤트가 발생한 HTML요소를 참조할 수 없습니다.

    e.target은 이벤트가 발생한 실제 HTML요소를 가리키는  반면, 
    e.currentTarget은 이벤트 리스너가 등록된 요소를 가리킵니다. 

    따라서 e.target을 사용하지 않으면 클릭된 버튼의 텍스트 내용을 변경할 수 없습니다. 
    대신 e.currentTarget을 사용하면 이벤트 리스너가 
    등록된 요소의 텍스트 내용을 변경할 수 있지만, 이는 의도한 동작과 다를 수 있습니다. 

    예를 들어, 이벤트 리스너가 상위 요소에 등록되어 있다면 e.currentTarget을 사용하면 
    상위 요소의 텍스트가 변경될 것입니다. 이는 사용자 경험 측면에서 바람직하지 않을 수 있습니다. 

    따라서 이벤트 핸들러 함수에서 이벤트가 발생한 실제 HTML 요소를 참조하려면 e.target을 사용해야 합니다.
    이를 통해 사용자의 의도에 맞는 동작을 구현할 수 있습니다
*/




/*
  JS 에서 이벤트 핸들러는 웹페이지나 앱에서 발생하는 이벤트
  (예: 클릭, 마우스 이동, 키 누름 등)을 처리한 함수를 가리킵니다.

  이벤트 핸들러는 특정 이벤트가 발생했을때 실행되도록 설정, 
  해당 이벤트에 대한 반응을 정의하는 역할을 합니다.

  보통 다음같은 상황에서 사용됩니다.
  1. 사용자 상호작용 처리
      사용자가 웹페이지의 요소를 클릭하거나 마우스를 움직이는 등의
      상호 작용을 할 때, 이벤트핸들러를 사용하여 해당 상호작용에 대한
      반응을 정의할 수 있습니다.
  2. 폼 제출 처리
      폼(form)이 제출될 때 이벤트 핸들러를 사용하여 폼데이터를 
      처리하거나 유효성 검사할 수 있습니다.
  3. 애니메이션 제어
      요소에 애니메이션을 적용하고, 애니메이션이 끝날 때마다 
      이벤트 핸들러를 사용하여 추가 작없을 수행할 수 있습니다.
  4. 비동기 작업 처리
      비동기적으로 데이터를 불러오거나 서버로부터 응답을 받을때,
      이벤트 핸들러를 사용하여 데이터를 처리하거나 UI를 업데이트할 수 있습니다.
 */



/*
이벤트 핸들러(Event Handler)는 웹 브라우저에서 발생하는 이벤트에 대응하여 실행되는 함수입니다. 

구체적으로 이벤트 핸들러는 다음과 같은 역할을 합니다:
  1 이벤트 발생 시 실행되는 코드 블록
      사용자의 동작(클릭, 스크롤, 입력 등)에 따라 발생하는 이벤트에 대응하여 실행됩니다. 

  2 이벤트 처리를 위한 함수
      이벤트가 발생했을 때 실행되도록 등록된 JavaScript 함수입니다. 

  3 이벤트와 동작을 연결하는 역할
      이벤트 발생 시 어떤 동작을 취할지 결정합니다. 

이벤트 핸들러는 HTML 요소의 속성으로 등록하거나, JavaScript에서 DOM 요소의 프로퍼티 또는 addEventListener() 메서드를 통해 등록할 수 있습니다. 

요약하면, 이벤트 핸들러는 웹 브라우저에서 발생하는 이벤트에 대응하여 실행되는 함수로, 사용자 동작에 따른 웹 페이지의 동작을 제어하는 역할을 합니다.

*/    





/* 참조 
--------------------------------------------------------------
//---------------------------------------------------------------

target은 HTML 요소의 속성 중 하나로, 링크된 문서가 열리는 위치를 지정

예)

1. `_self`: 현재 창/프레임에서 링크된 문서를 열음 (기본값)
2. `_blank`: 새로운 창이나 탭에서 링크된 문서를 엶
3. `_parent`: 현재 프레임의 상위 프레임에서 링크된 문서를 엶
4. `_top`: 최상위 프레임에서 링크된 문서를 엶
5. 창 이름: 지정된 창 이름에서 링크된 문서를 엶

`target="_blank"`를 사용하면 링크가 새 탭이나 창에서 열리게 됩니다. 


//-----------------------------------------------------------------

``` HTML
<h1 id="top">페이지 상단</h1>
<p>본문 내용</p>
<h2 id="middle">중간 섹션</h2>
<p>추가 내용</p>
<h2 id="bottom">하단 섹션</h2>
<p>마지막 내용</p>

```CSS -  id 선택자 
#top {
  color: blue;
}

#middle {
  color: green;
}

#bottom {
  color: red;
}

``` URL 에시
https://example.com/page.html#top
https://example.com/page.html#middle
https://example.com/page.html#bottom

HTML에서 각 섹션의 id 속성이 fragment identifier로 사용됩니다.

CSS에서 #top, #middle, #bottom은 id 선택자를 나타냅니다.

URL에서 #top, #middle, #bottom은 fragment identifier로 사용되어 해당 섹션으로 이동할 수 있습니다.

즉, CSS의 #은 id 선택자이고, URL의 #은 fragment identifier로 서로 다른 개념입니다.
------------------------------------------------------------


CSS에서 :target 가상 선택자는 URL의 fragment identifier(#)로 지정된 HTML 요소를 선택할 수 있게 해줍니다. 

구체적으로 :target 선택자는 다음과 같은 특징을 가집니다:
URL의 fragment identifier(#)로 지정된 요소를 선택할 수 있습니다. 

예를 들어 <a href="#section1">Section 1</a>과 같은 링크를 클릭하면 #section1이 fragment identifier가 되어 #section1 요소가 :target이 됩니다.
:target 요소에 스타일을 적용할 수 있습니다. 

예를 들어 :target { background-color: yellow; } 와 같이 스타일을 지정할 수 있습니다.
사용자가 링크를 클릭하여 특정 요소로 이동했을 때 시각적 피드백을 제공할 수 있습니다. 

예를 들어 :target으로 선택된 요소의 배경색을 변경하여 사용자에게 현재 위치를 알려줄 수 있습니다.
따라서 CSS의 :target 가상 선택자는 URL의 fragment identifier를 이용하여 특정 요소를 선택하고 스타일을 적용할 수 있게 해주는 유용한 기능입니다.



//-----------------------------------------------------------------


JS에서 target은 이벤트 객체의 속성으로, 이벤트가 발생한 HTML 요소를 나타냅니다. 

구체적으로 target 속성은 다음과 같은 특징을 가집니다:
이벤트가 발생한 실제 HTML 요소를 가리킵니다. 

예를 들어 버튼을 클릭하면 target은 클릭된 버튼 요소를 가리킵니다.
이벤트 핸들러 함수에서 target 속성을 사용하면 이벤트 발생 요소에 직접 접근할 수 있습니다. 
이를 통해 요소의 속성을 변경하거나 이벤트를 처리할 수 있습니다.

currentTarget과 구분됩니다. currentTarget은 이벤트 리스너가 등록된 요소를 가리킵니다. 

따라서 JS에서 target은 이벤트가 발생한 실제 HTML 요소를 참조할 수 있게 해주는 중요한 속성입니다. 이벤트 핸들러 함수에서 target을 사용하면 이벤트 발생 요소에 대한 직접적인 조작이 가능합니다. 

*/






